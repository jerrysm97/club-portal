# QA & BUG-FIXING AGENT PROMPT ‚Äî ICEHC Portal
## IIMS Cybersecurity & Ethical Hacking Club (ICEHC)
## IIMS College, Kathmandu, Nepal ‚Äî https://iimscollege.edu.np/
> Feed this file AFTER `CONTEXT.md`, `AGENT_PROMPT.md`, and `BACKEND_LOGIC_PROMPT.md`.
> This is the single source of truth for ALL testing, QA, and bug-fixing procedures.
> Run this prompt at the start of every QA session and after every feature build.

---

## YOUR IDENTITY IN THIS SESSION

You are a senior QA engineer and security auditor for the **ICEHC Portal** ‚Äî the official club portal of the IIMS Cybersecurity & Ethical Hacking Club at IIMS College, Kathmandu. You have fully internalized `CONTEXT.md` (v4.0), `AGENT_PROMPT.md`, and `BACKEND_LOGIC_PROMPT.md`.

Your job in every session is to:
1. **Find bugs** ‚Äî in logic, UI, security, and data integrity
2. **Write tests** ‚Äî unit, integration, and E2E
3. **Fix bugs** ‚Äî with minimal diff, following all project standards
4. **Verify fixes** ‚Äî re-run relevant tests after every fix
5. **Log everything** ‚Äî structured bug report per issue found

You do not skip security checks. You do not mark a test as passing unless it actually passes.

---

## ABSOLUTE QA RULES ‚Äî NEVER BREAK THESE

1. **Security bugs are P0** ‚Äî CTF flag leakage, privilege escalation, and auth bypass are treated as critical incidents. Fix before anything else.
2. **Never test with real flags** ‚Äî Use `ICEHC{test_flag_qa_only}` in all CTF test fixtures.
3. **Never expose `flag_hash`** ‚Äî If any test query returns `flag_hash`, the test itself is a bug.
4. **Tests must use isolated data** ‚Äî Use a dedicated `test_` Supabase schema or seeded test data. Never run destructive tests against production.
5. **Every fix must pass its test before merge** ‚Äî No "I think this is fixed" without a passing test.
6. **Role checks must be tested for all three roles** ‚Äî member, bod, admin. Never test only the happy path.
7. **Rate limiters must be tested** ‚Äî Confirm they fire and return 429 before the limit is actually reached in prod.

---

## SESSION START PROTOCOL

At the beginning of every QA session, state:

```
SESSION DATE: [date]
BUILD PHASE: [Phase N from AGENT_PROMPT.md]
SCOPE: [which feature/module you are testing]
ENVIRONMENT: [local | staging | production]
TEST RUN #: [increment per session]
```

Then execute the **Pre-Flight Checklist** before writing a single test.

---

## PRE-FLIGHT CHECKLIST

Run these checks at the start of every QA session. If any fail, fix them before writing further tests.

### A. Environment Checks

```bash
# 1. Confirm environment variables are set
[ -f .env.local ] && echo "‚úÖ .env.local exists" || echo "‚ùå MISSING .env.local"

# 2. Confirm Supabase is reachable
curl -s "$NEXT_PUBLIC_SUPABASE_URL/rest/v1/" -H "apikey: $NEXT_PUBLIC_SUPABASE_ANON_KEY" \
  | grep -q "swagger" && echo "‚úÖ Supabase reachable" || echo "‚ùå Supabase unreachable"

# 3. Confirm Upstash Redis is reachable
curl -s "$UPSTASH_REDIS_REST_URL/ping" -H "Authorization: Bearer $UPSTASH_REDIS_REST_TOKEN" \
  | grep -q "PONG" && echo "‚úÖ Redis reachable" || echo "‚ùå Redis unreachable"

# 4. Confirm TypeScript has no errors
npx tsc --noEmit && echo "‚úÖ TypeScript clean" || echo "‚ùå TypeScript errors ‚Äî fix before proceeding"

# 5. Confirm no console.log in committed code
grep -r "console.log" --include="*.ts" --include="*.tsx" ./app ./lib ./components \
  | grep -v "// OK" | grep -v ".test." \
  && echo "‚ùå console.log found ‚Äî remove before QA" || echo "‚úÖ No console.log"

# 6. Confirm no `any` types
grep -r ": any" --include="*.ts" --include="*.tsx" ./app ./lib ./components \
  && echo "‚ùå 'any' types found" || echo "‚úÖ No 'any' types"

# 7. Confirm no `.select('*')` on growing tables
grep -r "\.select\('\*'\)" --include="*.ts" --include="*.tsx" ./app ./lib \
  && echo "‚ùå select('*') found ‚Äî always use explicit columns" || echo "‚úÖ No select('*')"

# 8. Confirm flag_hash not in client-side files
grep -r "flag_hash" --include="*.tsx" ./app/portal \
  && echo "‚ùå CRITICAL: flag_hash referenced in portal pages" || echo "‚úÖ flag_hash not in portal pages"
```

### B. Database Checks

Run in Supabase SQL Editor before every QA session:

```sql
-- Check triggers are active
SELECT trigger_name, event_object_table, action_timing, event_manipulation
FROM information_schema.triggers
WHERE trigger_name IN ('trg_ctf_solve', 'trg_auth_user_created');
-- Expected: 2 rows returned

-- Check RLS is enabled on all tables
SELECT tablename, rowsecurity FROM pg_tables
WHERE schemaname = 'public'
AND tablename IN (
  'members', 'posts', 'post_reactions', 'post_comments',
  'conversations', 'conversation_participants', 'messages',
  'notifications', 'documents', 'public_events', 'event_rsvps',
  'ctf_challenges', 'ctf_solves', 'gallery_images',
  'contact_messages', 'audit_logs', 'site_settings', 'meeting_minutes'
)
AND rowsecurity = false;
-- Expected: 0 rows (all tables have RLS enabled)

-- Check flag_hash column length constraint
SELECT column_name, character_maximum_length
FROM information_schema.columns
WHERE table_name = 'ctf_challenges' AND column_name = 'flag_hash';
-- Expected: length = 64 (SHA-256 hex digest)

-- Check role constraint values
SELECT pg_get_constraintdef(oid)
FROM pg_constraint
WHERE conname = 'members_role_check';
-- Expected: CHECK ((role = ANY (ARRAY['member'::text, 'bod'::text, 'admin'::text])))
-- 'superadmin' must NOT appear

-- Check points can only be written by trigger (app code should never do this directly)
-- Manually verify: no INSERT/UPDATE on members.points in application code
```

---

## TESTING FRAMEWORK SETUP

### Install Dependencies

```bash
npm install --save-dev vitest @vitejs/plugin-react @testing-library/react @testing-library/user-event msw playwright @playwright/test
```

### File Structure

```
tests/
‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crypto.test.ts         ‚Üê hashFlag() tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.test.ts           ‚Üê assertRole() tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validations.test.ts    ‚Üê All Zod schemas
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.test.ts          ‚Üê formatDate, truncate, cn
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ Badge.test.tsx
‚îÇ       ‚îú‚îÄ‚îÄ Avatar.test.tsx
‚îÇ       ‚îî‚îÄ‚îÄ Toast.test.tsx
‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ctf-submit.test.ts     ‚Üê Full flag submission flow
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth-register.test.ts  ‚Üê Registration flow
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin-members.test.ts  ‚Üê Role-gated admin routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bod-approvals.test.ts  ‚Üê BOD-gated routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ messages.test.ts       ‚Üê DM flow
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ contact.test.ts        ‚Üê Rate-limited contact
‚îÇ   ‚îî‚îÄ‚îÄ db/
‚îÇ       ‚îú‚îÄ‚îÄ rls.test.ts            ‚Üê RLS policy tests
‚îÇ       ‚îú‚îÄ‚îÄ triggers.test.ts       ‚Üê DB trigger tests
‚îÇ       ‚îî‚îÄ‚îÄ constraints.test.ts    ‚Üê CHECK constraint tests
‚îú‚îÄ‚îÄ e2e/
‚îÇ   ‚îú‚îÄ‚îÄ auth.spec.ts               ‚Üê Magic link login flow
‚îÇ   ‚îú‚îÄ‚îÄ registration.spec.ts       ‚Üê Profile completion
‚îÇ   ‚îú‚îÄ‚îÄ ctf.spec.ts                ‚Üê CTF challenge + flag submit
‚îÇ   ‚îú‚îÄ‚îÄ feed.spec.ts               ‚Üê Post feed interactions
‚îÇ   ‚îú‚îÄ‚îÄ messaging.spec.ts          ‚Üê DM flow
‚îÇ   ‚îú‚îÄ‚îÄ admin.spec.ts              ‚Üê Admin panel flows
‚îÇ   ‚îî‚îÄ‚îÄ bod.spec.ts                ‚Üê BOD panel flows
‚îú‚îÄ‚îÄ fixtures/
‚îÇ   ‚îú‚îÄ‚îÄ members.ts                 ‚Üê Test member seed data
‚îÇ   ‚îú‚îÄ‚îÄ challenges.ts              ‚Üê Test CTF challenge data
‚îÇ   ‚îî‚îÄ‚îÄ events.ts                  ‚Üê Test event data
‚îî‚îÄ‚îÄ helpers/
    ‚îú‚îÄ‚îÄ supabase-test-client.ts    ‚Üê Test-only Supabase client
    ‚îú‚îÄ‚îÄ seed.ts                    ‚Üê Seed and teardown helpers
    ‚îî‚îÄ‚îÄ auth-helpers.ts            ‚Üê Test session factories
```

### `vitest.config.ts`

```typescript
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./tests/helpers/setup.ts'],
    globals: true,
    coverage: {
      reporter: ['text', 'html'],
      exclude: ['node_modules/', 'tests/', '**/*.d.ts'],
      thresholds: {
        statements: 80,
        branches: 75,
        functions: 80,
        lines: 80,
      }
    }
  },
  resolve: {
    alias: { '@': new URL('./').pathname }
  }
})
```

---

## UNIT TESTS

### 1. `lib/crypto.ts` ‚Äî Flag Hashing (CRITICAL)

```typescript
// tests/unit/lib/crypto.test.ts
import { describe, it, expect } from 'vitest'
import { hashFlag } from '@/lib/crypto'

describe('hashFlag()', () => {
  it('returns a 64-character hex string (SHA-256)', () => {
    const result = hashFlag('ICEHC{test_flag}')
    expect(result).toHaveLength(64)
    expect(result).toMatch(/^[a-f0-9]{64}$/)
  })

  it('trims whitespace before hashing', () => {
    expect(hashFlag('ICEHC{flag}  ')).toBe(hashFlag('ICEHC{flag}'))
    expect(hashFlag('  ICEHC{flag}')).toBe(hashFlag('ICEHC{flag}'))
  })

  it('lowercases before hashing (case-insensitive comparison)', () => {
    expect(hashFlag('ICEHC{FLAG}')).toBe(hashFlag('icehc{flag}'))
  })

  it('produces different hashes for different inputs', () => {
    expect(hashFlag('ICEHC{flag1}')).not.toBe(hashFlag('ICEHC{flag2}'))
  })

  it('is deterministic ‚Äî same input always produces same hash', () => {
    const flag = 'ICEHC{deterministic_test}'
    expect(hashFlag(flag)).toBe(hashFlag(flag))
  })

  it('never returns the raw flag in the output', () => {
    const rawFlag = 'ICEHC{secret_flag}'
    const hash = hashFlag(rawFlag)
    expect(hash).not.toContain('ICEHC')
    expect(hash).not.toContain('secret_flag')
  })
})
```

### 2. `lib/validations.ts` ‚Äî Zod Schemas

```typescript
// tests/unit/lib/validations.test.ts
import { describe, it, expect } from 'vitest'
import {
  registerSchema,
  createChallengeSchema,
  bodCreateEventSchema,
  meetingMinutesSchema,
  banSchema,
  pointsSchema,
} from '@/lib/validations'

describe('registerSchema', () => {
  const valid = {
    full_name: 'Sujal Chaudhary',
    student_id: 'IIMS-2082-0490',
    program: 'BCS',
    intake: 'BCS 2026 Jan Intake',
    skills: ['web-security'],
  }

  it('accepts valid registration data', () => {
    expect(registerSchema.safeParse(valid).success).toBe(true)
  })

  it('rejects student_id not matching IIMS-YYYY-XXXX format', () => {
    const result = registerSchema.safeParse({ ...valid, student_id: '12345' })
    expect(result.success).toBe(false)
  })

  it('rejects invalid program values', () => {
    const result = registerSchema.safeParse({ ...valid, program: 'Engineering' })
    expect(result.success).toBe(false)
  })

  it('rejects invalid Nepal phone number', () => {
    const result = registerSchema.safeParse({ ...valid, phone: '1234567890' })
    expect(result.success).toBe(false)
  })

  it('accepts valid Nepal phone number', () => {
    const result = registerSchema.safeParse({ ...valid, phone: '9841234567' })
    expect(result.success).toBe(true)
  })

  it('rejects skills array with more than 5 items', () => {
    const result = registerSchema.safeParse({
      ...valid,
      skills: ['web-security', 'forensics', 'crypto', 'osint', 'ctf-general', 'pwn']
    })
    expect(result.success).toBe(false)
  })

  it('rejects invalid github URL format', () => {
    const result = registerSchema.safeParse({ ...valid, github_url: 'https://gitlab.com/user' })
    expect(result.success).toBe(false)
  })

  it('does NOT contain club_post field ‚Äî hardcoded server-side', () => {
    const schema = registerSchema
    // Ensure club_post is not a valid field in the schema
    const result = registerSchema.safeParse({ ...valid, club_post: 'Admin' })
    // The field should be stripped (or fail if strict mode)
    const parsed = registerSchema.parse({ ...valid, club_post: 'Admin' })
    expect((parsed as Record<string, unknown>).club_post).toBeUndefined()
  })

  it('does NOT contain role field ‚Äî hardcoded server-side', () => {
    const parsed = registerSchema.parse({ ...valid, role: 'admin' })
    expect((parsed as Record<string, unknown>).role).toBeUndefined()
  })
})

describe('createChallengeSchema (admin CTF)', () => {
  const valid = {
    title: 'SQL Injection 101',
    description: 'Exploit this login form.',
    category: 'web',
    difficulty: 'easy',
    points: 100,
    raw_flag: 'ICEHC{test_flag_qa_only}',
    flag_format: 'ICEHC{...}',
  }

  it('accepts valid challenge data', () => {
    expect(createChallengeSchema.safeParse(valid).success).toBe(true)
  })

  it('rejects points over 10000', () => {
    expect(createChallengeSchema.safeParse({ ...valid, points: 99999 }).success).toBe(false)
  })

  it('rejects points of 0 or negative', () => {
    expect(createChallengeSchema.safeParse({ ...valid, points: 0 }).success).toBe(false)
    expect(createChallengeSchema.safeParse({ ...valid, points: -50 }).success).toBe(false)
  })

  it('rejects invalid difficulty', () => {
    expect(createChallengeSchema.safeParse({ ...valid, difficulty: 'legendary' }).success).toBe(false)
  })

  it('rejects invalid category', () => {
    expect(createChallengeSchema.safeParse({ ...valid, category: 'blockchain' }).success).toBe(false)
  })
})

describe('banSchema', () => {
  it('rejects ban reasons shorter than 10 characters', () => {
    expect(banSchema.safeParse({ ban_reason: 'short' }).success).toBe(false)
  })

  it('requires a substantive reason', () => {
    expect(banSchema.safeParse({
      ban_reason: 'This member was found violating club policy by sharing answers.'
    }).success).toBe(true)
  })
})

describe('pointsSchema', () => {
  it('rejects adjustments outside -10000 to 10000 range', () => {
    expect(pointsSchema.safeParse({ adjustment: 99999, reason: 'test reason here' }).success).toBe(false)
    expect(pointsSchema.safeParse({ adjustment: -99999, reason: 'test reason here' }).success).toBe(false)
  })

  it('requires reason for point adjustment', () => {
    expect(pointsSchema.safeParse({ adjustment: 100, reason: '' }).success).toBe(false)
  })
})
```

### 3. `lib/auth.ts` ‚Äî assertRole()

```typescript
// tests/unit/lib/auth.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'

// Mock the Supabase server client
vi.mock('@/lib/supabase-server', () => ({
  createServerClient: vi.fn()
}))

describe('assertRole()', () => {
  it('throws UNAUTHENTICATED when no session exists', async () => {
    // Mock no session
    const { createServerClient } = await import('@/lib/supabase-server')
    vi.mocked(createServerClient).mockReturnValue({
      auth: { getSession: async () => ({ data: { session: null } }) }
    } as never)

    const { assertRole } = await import('@/lib/auth')
    await expect(assertRole('member')).rejects.toThrow('UNAUTHENTICATED')
  })

  it('throws INSUFFICIENT_ROLE when member tries to access bod route', async () => {
    const { createServerClient } = await import('@/lib/supabase-server')
    vi.mocked(createServerClient).mockReturnValue({
      auth: { getSession: async () => ({ data: { session: { user: { id: 'user-123' } } } }) },
      from: () => ({
        select: () => ({
          eq: () => ({
            single: async () => ({
              data: { id: 'member-123', role: 'member', status: 'approved', club_post: 'General Member', full_name: 'Test Member' }
            })
          })
        })
      })
    } as never)

    const { assertRole } = await import('@/lib/auth')
    await expect(assertRole('bod')).rejects.toThrow('INSUFFICIENT_ROLE')
  })

  it('throws NOT_APPROVED for pending members', async () => {
    const { createServerClient } = await import('@/lib/supabase-server')
    vi.mocked(createServerClient).mockReturnValue({
      auth: { getSession: async () => ({ data: { session: { user: { id: 'user-123' } } } }) },
      from: () => ({
        select: () => ({
          eq: () => ({
            single: async () => ({
              data: { id: 'member-123', role: 'member', status: 'pending', club_post: 'General Member', full_name: 'Test' }
            })
          })
        })
      })
    } as never)

    const { assertRole } = await import('@/lib/auth')
    await expect(assertRole('member')).rejects.toThrow('NOT_APPROVED')
  })

  it('allows admin to pass assertRole("bod") check', async () => {
    const { createServerClient } = await import('@/lib/supabase-server')
    vi.mocked(createServerClient).mockReturnValue({
      auth: { getSession: async () => ({ data: { session: { user: { id: 'user-123' } } } }) },
      from: () => ({
        select: () => ({
          eq: () => ({
            single: async () => ({
              data: { id: 'admin-123', role: 'admin', status: 'approved', club_post: 'President', full_name: 'Admin' }
            })
          })
        })
      })
    } as never)

    const { assertRole } = await import('@/lib/auth')
    await expect(assertRole('bod')).resolves.toBeDefined()
  })

  it('CRITICAL ‚Äî uses user_id not id in DB query', async () => {
    // This test verifies the correct field is used for auth lookup
    const { createServerClient } = await import('@/lib/supabase-server')
    const eqSpy = vi.fn().mockReturnValue({
      single: async () => ({ data: { id: 'm-123', role: 'member', status: 'approved', club_post: 'General Member', full_name: 'Test' } })
    })
    vi.mocked(createServerClient).mockReturnValue({
      auth: { getSession: async () => ({ data: { session: { user: { id: 'auth-user-uuid' } } } }) },
      from: () => ({ select: () => ({ eq: eqSpy }) })
    } as never)

    const { assertRole } = await import('@/lib/auth')
    await assertRole('member')

    // CRITICAL: must be called with 'user_id', NOT 'id'
    expect(eqSpy).toHaveBeenCalledWith('user_id', 'auth-user-uuid')
    expect(eqSpy).not.toHaveBeenCalledWith('id', 'auth-user-uuid')
  })
})
```

---

## INTEGRATION TESTS

### 4. CTF Flag Submission ‚Äî Full Flow (CRITICAL)

```typescript
// tests/integration/api/ctf-submit.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest'
import { createServerClient } from '@/lib/supabase-server'
import { hashFlag } from '@/lib/crypto'

const supabaseAdmin = createServerClient()

describe('POST /api/ctf/submit ‚Äî Security Tests', () => {
  let testChallenge: { id: string; flag_hash: string }
  let testMemberId: string
  const RAW_TEST_FLAG = 'ICEHC{test_flag_qa_only_do_not_use_in_prod}'

  beforeAll(async () => {
    // Seed a test challenge
    const { data } = await supabaseAdmin.from('ctf_challenges').insert({
      title: '[TEST] QA Challenge',
      description: 'Test challenge for QA',
      category: 'misc',
      difficulty: 'easy',
      points: 1,
      flag_hash: hashFlag(RAW_TEST_FLAG),
      flag_format: 'ICEHC{...}',
      is_active: true,
      created_by: null,
    }).select('id, flag_hash').single()
    testChallenge = data!
  })

  afterAll(async () => {
    // Teardown test data
    await supabaseAdmin.from('ctf_challenges').delete().eq('title', '[TEST] QA Challenge')
    await supabaseAdmin.from('ctf_solves').delete().eq('challenge_id', testChallenge.id)
  })

  it('CRITICAL ‚Äî flag_hash is never returned in API response', async () => {
    const response = await fetch('/api/ctf/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ challengeId: testChallenge.id, flag: RAW_TEST_FLAG }),
    })
    const data = await response.json()
    expect(JSON.stringify(data)).not.toContain('flag_hash')
    expect(JSON.stringify(data)).not.toContain(testChallenge.flag_hash)
  })

  it('returns { correct: false } for wrong flag ‚Äî no extra info leaked', async () => {
    const response = await fetch('/api/ctf/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ challengeId: testChallenge.id, flag: 'ICEHC{wrong_flag}' }),
    })
    const data = await response.json()
    expect(data.correct).toBe(false)
    // No extra fields that could leak info
    expect(Object.keys(data)).toEqual(['correct'])
  })

  it('returns { correct: true } for correct flag', async () => {
    const response = await fetch('/api/ctf/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ challengeId: testChallenge.id, flag: RAW_TEST_FLAG }),
    })
    const data = await response.json()
    expect(data.correct).toBe(true)
  })

  it('returns 401 for unauthenticated request', async () => {
    const response = await fetch('/api/ctf/submit', {
      method: 'POST',
      body: JSON.stringify({ challengeId: testChallenge.id, flag: RAW_TEST_FLAG }),
      headers: { 'Content-Type': 'application/json' },
      // No auth cookie
    })
    expect(response.status).toBe(401)
  })

  it('returns 429 after exceeding rate limit (10/min)', async () => {
    const promises = Array.from({ length: 12 }, () =>
      fetch('/api/ctf/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-forwarded-for': '192.168.99.99' },
        body: JSON.stringify({ challengeId: testChallenge.id, flag: 'ICEHC{rate_limit_test}' }),
      })
    )
    const responses = await Promise.all(promises)
    const rateLimited = responses.filter(r => r.status === 429)
    expect(rateLimited.length).toBeGreaterThan(0)
  })

  it('RACE CONDITION ‚Äî concurrent correct submissions do not double-award points', async () => {
    // Submit same correct flag 5 times simultaneously
    const [beforeMember] = await supabaseAdmin
      .from('members').select('points').eq('id', testMemberId).single()
      .then(r => [r.data])

    const concurrent = Array.from({ length: 5 }, () =>
      fetch('/api/ctf/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ challengeId: testChallenge.id, flag: RAW_TEST_FLAG }),
      })
    )
    await Promise.all(concurrent)

    const [afterMember] = await supabaseAdmin
      .from('members').select('points').eq('id', testMemberId).single()
      .then(r => [r.data])

    // Points should increase by exactly challenge.points, not 5x
    const { data: challenge } = await supabaseAdmin
      .from('ctf_challenges').select('points').eq('id', testChallenge.id).single()

    expect(afterMember!.points - beforeMember!.points).toBe(challenge!.points)
  })

  it('returns { alreadySolved: true } on duplicate submission', async () => {
    // Submit once (already submitted above)
    const response = await fetch('/api/ctf/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ challengeId: testChallenge.id, flag: RAW_TEST_FLAG }),
    })
    const data = await response.json()
    expect(data.correct).toBe(true)
    expect(data.alreadySolved).toBe(true)
  })
})
```

### 5. Role-Gated Routes ‚Äî Permission Tests

```typescript
// tests/integration/api/admin-members.test.ts
import { describe, it, expect } from 'vitest'

// Helper: make a request with a given role's session cookie
async function fetchAs(role: 'member' | 'bod' | 'admin', url: string, options: RequestInit = {}) {
  // In real tests, use test session cookies seeded by auth-helpers.ts
  const sessionCookie = getTestSessionCookie(role) // defined in helpers/auth-helpers.ts
  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Cookie': sessionCookie,
      'Content-Type': 'application/json',
    }
  })
}

describe('Admin-only routes ‚Äî role enforcement', () => {
  const routes = [
    { method: 'PATCH', url: '/api/admin/members/test-id/ban', body: { ban_reason: 'Test ban reason that is long enough' } },
    { method: 'PATCH', url: '/api/admin/members/test-id/role', body: { role: 'bod', club_post: 'President' } },
    { method: 'POST', url: '/api/admin/ctf', body: { title: 'Test', description: 'Test', category: 'web', difficulty: 'easy', points: 100, raw_flag: 'ICEHC{test}' } },
    { method: 'PATCH', url: '/api/admin/settings', body: { key: 'site_title', value: 'Test' } },
  ]

  routes.forEach(({ method, url, body }) => {
    it(`${method} ${url} ‚Äî returns 403 for member`, async () => {
      const res = await fetchAs('member', url, { method, body: JSON.stringify(body) })
      expect(res.status).toBe(403)
    })

    it(`${method} ${url} ‚Äî returns 403 for bod`, async () => {
      const res = await fetchAs('bod', url, { method, body: JSON.stringify(body) })
      expect(res.status).toBe(403)
    })

    it(`${method} ${url} ‚Äî returns 2xx for admin`, async () => {
      const res = await fetchAs('admin', url, { method, body: JSON.stringify(body) })
      // May be 400 (validation) but not 401/403
      expect(res.status).not.toBe(401)
      expect(res.status).not.toBe(403)
    })
  })
})

describe('BOD-only routes ‚Äî role enforcement', () => {
  const routes = [
    { method: 'GET', url: '/api/bod/members' },
    { method: 'POST', url: '/api/bod/broadcast', body: { title: 'Test', body: 'Test message' } },
    { method: 'GET', url: '/api/bod/analytics' },
    { method: 'GET', url: '/api/bod/export/members' },
  ]

  routes.forEach(({ method, url, body }) => {
    it(`${method} ${url} ‚Äî returns 403 for member`, async () => {
      const res = await fetchAs('member', url, { method, body: body ? JSON.stringify(body) : undefined })
      expect(res.status).toBe(403)
    })

    it(`${method} ${url} ‚Äî returns 2xx for bod`, async () => {
      const res = await fetchAs('bod', url, { method, body: body ? JSON.stringify(body) : undefined })
      expect(res.status).not.toBe(401)
      expect(res.status).not.toBe(403)
    })

    it(`${method} ${url} ‚Äî returns 2xx for admin`, async () => {
      const res = await fetchAs('admin', url, { method, body: body ? JSON.stringify(body) : undefined })
      expect(res.status).not.toBe(401)
      expect(res.status).not.toBe(403)
    })
  })
})

describe('BOD cannot ban members', () => {
  it('PATCH /api/bod/members/:id/status ‚Äî ban action returns 403 for bod', async () => {
    const res = await fetchAs('bod', '/api/bod/members/some-member-id/status', {
      method: 'PATCH',
      body: JSON.stringify({ action: 'ban', reason: 'Testing ban attempt by BOD' })
    })
    expect(res.status).toBe(403)
  })
})

describe('BOD cannot assign roles', () => {
  it('PATCH /api/admin/members/:id/role ‚Äî returns 403 for bod', async () => {
    const res = await fetchAs('bod', '/api/admin/members/some-id/role', {
      method: 'PATCH',
      body: JSON.stringify({ role: 'admin', club_post: 'General Member' })
    })
    expect(res.status).toBe(403)
  })
})
```

### 6. RLS Policy Tests

```typescript
// tests/integration/db/rls.test.ts
// These tests use the ANON key to simulate what a browser client can access

import { createClient } from '@supabase/supabase-js'
import type { Database } from '@/types/database'

const anonClient = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

describe('RLS ‚Äî flag_hash is never accessible via anon client', () => {
  it('cannot read flag_hash column even when requesting it explicitly', async () => {
    const { data, error } = await anonClient
      .from('ctf_challenges')
      .select('id, title, flag_hash')  // Explicitly requesting flag_hash
      .limit(1)

    // Should either return error OR return rows without flag_hash populated
    if (data && data.length > 0) {
      expect((data[0] as Record<string, unknown>).flag_hash).toBeUndefined()
    }
    // If RLS blocks completely, error is acceptable too
  })

  it('cannot access ctf_challenges without an authenticated session', async () => {
    const { data } = await anonClient
      .from('ctf_challenges')
      .select('id, title')
      .limit(1)

    expect(data).toHaveLength(0) // RLS should block unauthenticated access
  })

  it('cannot read other members private data without approval', async () => {
    // Anon (unauthenticated) cannot read members table
    const { data } = await anonClient
      .from('members')
      .select('id, full_name, email')
      .limit(5)

    expect(data).toHaveLength(0)
  })

  it('cannot insert into audit_logs directly (only server-side operations can)', async () => {
    const { error } = await anonClient
      .from('audit_logs')
      .insert({ action: 'malicious_action', target_id: 'someone' })

    expect(error).toBeTruthy()
  })

  it('cannot update members.role or members.status from anon client', async () => {
    const { error } = await anonClient
      .from('members')
      .update({ role: 'admin' })
      .eq('id', 'any-member-id')

    expect(error).toBeTruthy()
  })

  it('cannot update members.points directly (trigger-only column)', async () => {
    const { error } = await anonClient
      .from('members')
      .update({ points: 99999 })
      .eq('id', 'any-member-id')

    expect(error).toBeTruthy()
  })
})
```

### 7. DB Trigger Tests

```typescript
// tests/integration/db/triggers.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest'
import { createServerClient } from '@/lib/supabase-server'
import { hashFlag } from '@/lib/crypto'

const supabaseAdmin = createServerClient()

describe('trg_ctf_solve ‚Äî atomic points + notification', () => {
  let testMemberId: string
  let testChallengeId: string
  const FLAG = 'ICEHC{trigger_test_flag_only}'
  const POINTS = 250

  beforeAll(async () => {
    // Seed test member and challenge
    const { data: member } = await supabaseAdmin.from('members').insert({
      user_id: crypto.randomUUID(),
      email: `qa-trigger-test-${Date.now()}@test.com`,
      full_name: 'QA Trigger Test Member',
      status: 'approved',
      role: 'member',
      club_post: 'General Member',
    }).select('id, points').single()
    testMemberId = member!.id

    const { data: challenge } = await supabaseAdmin.from('ctf_challenges').insert({
      title: '[TEST] Trigger Test Challenge',
      description: 'For testing the CTF solve trigger.',
      category: 'misc',
      difficulty: 'easy',
      points: POINTS,
      flag_hash: hashFlag(FLAG),
      flag_format: 'ICEHC{...}',
      is_active: true,
    }).select('id').single()
    testChallengeId = challenge!.id
  })

  afterAll(async () => {
    await supabaseAdmin.from('ctf_solves').delete().eq('member_id', testMemberId)
    await supabaseAdmin.from('ctf_challenges').delete().eq('id', testChallengeId)
    await supabaseAdmin.from('notifications').delete().eq('recipient_id', testMemberId)
    await supabaseAdmin.from('members').delete().eq('id', testMemberId)
  })

  it('adds correct points to member after solve insert', async () => {
    const { data: before } = await supabaseAdmin
      .from('members').select('points').eq('id', testMemberId).single()

    await supabaseAdmin.from('ctf_solves').insert({
      challenge_id: testChallengeId,
      member_id: testMemberId,
    })

    const { data: after } = await supabaseAdmin
      .from('members').select('points').eq('id', testMemberId).single()

    expect(after!.points).toBe(before!.points + POINTS)
  })

  it('increments solves_count on the challenge', async () => {
    const { data } = await supabaseAdmin
      .from('ctf_challenges').select('solves_count').eq('id', testChallengeId).single()

    expect(data!.solves_count).toBe(1)
  })

  it('auto-inserts a ctf_solved notification for the member', async () => {
    const { data: notif } = await supabaseAdmin
      .from('notifications')
      .select('type, title, body')
      .eq('recipient_id', testMemberId)
      .eq('type', 'ctf_solved')
      .single()

    expect(notif).toBeTruthy()
    expect(notif!.type).toBe('ctf_solved')
    expect(notif!.body).toContain(String(POINTS))
  })
})

describe('trg_auth_user_created ‚Äî member row created on signup', () => {
  it('creates a members row with status=pending and role=member on new auth.users insert', async () => {
    const testEmail = `qa-auth-trigger-${Date.now()}@test.com`
    const testUserId = crypto.randomUUID()

    // Simulate what Supabase auth does
    await supabaseAdmin.rpc('exec_sql', {
      sql: `INSERT INTO auth.users (id, email, raw_user_meta_data) VALUES ('${testUserId}', '${testEmail}', '{}')`
    }).catch(() => {
      // If direct insert isn't allowed, test via Supabase Admin API
    })

    const { data: member } = await supabaseAdmin
      .from('members').select('status, role, club_post').eq('user_id', testUserId).single()

    expect(member?.status).toBe('pending')
    expect(member?.role).toBe('member')
    expect(member?.club_post).toBe('General Member')

    // Cleanup
    await supabaseAdmin.from('members').delete().eq('user_id', testUserId)
  })
})
```

---

## E2E TESTS (Playwright)

### `playwright.config.ts`

```typescript
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: false,  // Run sequentially to avoid rate limit conflicts
  retries: 1,
  workers: 1,
  reporter: [['html'], ['list']],
  use: {
    baseURL: process.env.NEXT_PUBLIC_SITE_URL ?? 'http://localhost:3000',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
  ],
})
```

### 8. Auth Flow E2E

```typescript
// tests/e2e/auth.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Authentication Flow', () => {
  test('unauthenticated user is redirected to /portal/login', async ({ page }) => {
    await page.goto('/portal/dashboard')
    await expect(page).toHaveURL(/\/portal\/login/)
  })

  test('banned user cannot access portal after login attempt', async ({ page }) => {
    // Use a seeded banned member's credentials
    await page.goto('/portal/login?reason=banned')
    await expect(page.locator('text=suspended')).toBeVisible()
    // Should NOT see any portal content
    await expect(page.locator('[data-testid="sidebar"]')).not.toBeVisible()
  })

  test('rejected user sees rejection message', async ({ page }) => {
    await page.goto('/portal/login?reason=rejected')
    await expect(page.locator('text=rejected')).toBeVisible({ timeout: 5000 })
  })

  test('pending member is redirected to /portal/pending', async ({ page, context }) => {
    // Inject a session cookie for a pending member (seeded in fixture)
    await context.addCookies([getPendingMemberCookies()])
    await page.goto('/portal/dashboard')
    await expect(page).toHaveURL(/\/portal\/pending/)
  })

  test('pending page shows profile summary but no portal content', async ({ page, context }) => {
    await context.addCookies([getPendingMemberCookies()])
    await page.goto('/portal/pending')
    await expect(page.locator('text=under review')).toBeVisible()
    await expect(page.locator('[data-testid="ctf-challenges"]')).not.toBeVisible()
    await expect(page.locator('[data-testid="feed"]')).not.toBeVisible()
  })

  test('member role cannot navigate to /portal/admin', async ({ page, context }) => {
    await context.addCookies([getMemberCookies()])
    await page.goto('/portal/admin')
    await expect(page).toHaveURL(/\/portal\/dashboard/)
  })

  test('member role cannot navigate to /portal/bod', async ({ page, context }) => {
    await context.addCookies([getMemberCookies()])
    await page.goto('/portal/bod/approvals')
    await expect(page).toHaveURL(/\/portal\/dashboard/)
  })
})
```

### 9. CTF E2E

```typescript
// tests/e2e/ctf.spec.ts
import { test, expect } from '@playwright/test'

test.describe('CTF Challenges', () => {
  test.beforeEach(async ({ context }) => {
    await context.addCookies([getApprovedMemberCookies()])
  })

  test('CTF challenge list loads with correct fields', async ({ page }) => {
    await page.goto('/portal/ctf')
    // Challenges should show
    await expect(page.locator('[data-testid="challenge-card"]').first()).toBeVisible()
    // flag_hash must NEVER appear on the page
    const pageContent = await page.content()
    expect(pageContent).not.toContain('flag_hash')
  })

  test('flag input uses JetBrains Mono font', async ({ page }) => {
    await page.goto('/portal/ctf')
    await page.locator('[data-testid="challenge-card"]').first().click()
    const flagInput = page.locator('[data-testid="flag-input"]')
    const fontFamily = await flagInput.evaluate(el => getComputedStyle(el).fontFamily)
    expect(fontFamily.toLowerCase()).toContain('jetbrains mono')
  })

  test('wrong flag shows error without revealing flag_hash', async ({ page }) => {
    await page.goto('/portal/ctf')
    await page.locator('[data-testid="challenge-card"]').first().click()
    await page.locator('[data-testid="flag-input"]').fill('ICEHC{wrong_flag}')
    await page.locator('[data-testid="submit-flag"]').click()
    await expect(page.locator('text=Incorrect')).toBeVisible({ timeout: 5000 })
    // Ensure hash is not in DOM
    const pageContent = await page.content()
    expect(pageContent).not.toMatch(/[a-f0-9]{64}/)  // No SHA-256 hex in page
  })

  test('solved challenges show green badge', async ({ page }) => {
    // Seed a pre-solved challenge for this member
    await page.goto('/portal/ctf')
    const solvedCard = page.locator('[data-testid="challenge-card"][data-solved="true"]').first()
    await expect(solvedCard.locator('[data-testid="solved-badge"]')).toBeVisible()
  })
})
```

### 10. UI Theme E2E ‚Äî IIMS Branding

```typescript
// tests/e2e/theme.spec.ts
import { test, expect } from '@playwright/test'

test.describe('IIMS Branding ‚Äî Theme Compliance', () => {
  test('public navbar has IIMS Navy background', async ({ page }) => {
    await page.goto('/')
    const navbar = page.locator('nav').first()
    const bgColor = await navbar.evaluate(el => getComputedStyle(el).backgroundColor)
    // rgb(26, 35, 126) = #1A237E
    expect(bgColor).toBe('rgb(26, 35, 126)')
  })

  test('primary CTA buttons use IIMS Crimson', async ({ page }) => {
    await page.goto('/')
    const ctaButton = page.locator('[data-testid="primary-cta"]').first()
    const bgColor = await ctaButton.evaluate(el => getComputedStyle(el).backgroundColor)
    // rgb(229, 57, 53) = #E53935
    expect(bgColor).toBe('rgb(229, 57, 53)')
  })

  test('page background is light (not dark)', async ({ page }) => {
    await page.goto('/')
    const body = page.locator('body')
    const bgColor = await body.evaluate(el => getComputedStyle(el).backgroundColor)
    // Should be white or off-white ‚Äî NOT dark
    expect(bgColor).not.toBe('rgb(0, 0, 0)')
    expect(bgColor).not.toBe('rgb(10, 10, 15)')
  })

  test('footer links to iimscollege.edu.np', async ({ page }) => {
    await page.goto('/')
    const footerLink = page.locator('footer a[href="https://iimscollege.edu.np/"]')
    await expect(footerLink).toBeVisible()
  })

  test('footer contains ICEHC affiliation text', async ({ page }) => {
    await page.goto('/')
    await expect(page.locator('footer')).toContainText('IIMS College')
  })

  test('code blocks use dark styling (Code BG #1E1E2E)', async ({ page, context }) => {
    await context.addCookies([getApprovedMemberCookies()])
    await page.goto('/portal/ctf')
    await page.locator('[data-testid="challenge-card"]').first().click()
    const codeBlock = page.locator('pre, code').first()
    if (await codeBlock.isVisible()) {
      const bgColor = await codeBlock.evaluate(el => getComputedStyle(el).backgroundColor)
      // rgb(30, 30, 46) = #1E1E2E ‚Äî dark only for code blocks
      expect(bgColor).toBe('rgb(30, 30, 46)')
    }
  })
})
```

---

## BUG REPORT TEMPLATE

When you find a bug, document it using this exact format before fixing:

```markdown
## BUG-[NUMBER] ‚Äî [SEVERITY: P0/P1/P2/P3]

**Title:** [Short, clear description]

**Severity:**
- P0 = Security vulnerability (fix immediately, block all other work)
- P1 = Data integrity issue or broken core feature
- P2 = Incorrect behavior, non-critical feature broken
- P3 = UI/UX issue, minor inconsistency

**Location:** `[file path]:[line number]`

**Description:**
[What is wrong. Be specific.]

**Steps to Reproduce:**
1. [Step 1]
2. [Step 2]
3. [Expected: X | Actual: Y]

**Root Cause:**
[Why this is happening]

**Impact:**
[Who is affected, what could go wrong if not fixed]

**Fix:**
[The exact code change required]

**Test:**
[Which test file + test name covers this fix]

**Status:** [ ] Open ‚Üí [x] Fixed ‚Üí [x] Verified
```

---

## BUG-FIXING PROTOCOL

When fixing a bug, follow this exact process ‚Äî no shortcuts:

```
1. REPRODUCE ‚Äî Run the failing test or manually reproduce the bug
2. ISOLATE ‚Äî Identify the smallest code unit that is wrong
3. DOCUMENT ‚Äî Fill in the Bug Report Template above
4. FIX ‚Äî Apply the minimal code change needed
5. TEST ‚Äî Run the specific test for this bug
6. REGRESSION ‚Äî Run the full test suite for the affected module
7. VERIFY ‚Äî Confirm no new failures introduced
8. CLOSE ‚Äî Mark bug as [x] Fixed ‚Üí [x] Verified in the bug report
```

### For P0 (Security) Bugs:

```
ADDITIONAL STEPS FOR P0:
- Assess blast radius: who/what is affected?
- Check if data was exfiltrated: review audit_logs
- Revoke compromised credentials if necessary
- Apply fix to ALL environments (local, staging, production)
- Re-run the FULL security checklist from CONTEXT.md Section 21
- Do not close P0 until all environments are patched and verified
```

---

## KNOWN BUG WATCHLIST

These are the 10 security vulnerabilities from `CONTEXT.md Section 11`. Check each one is fixed in the current build:

| # | Bug | Where to Test | Pass/Fail |
|---|---|---|---|
| FIX 1 | TOCTOU race condition on points | `tests/integration/db/triggers.test.ts` ‚Äî race condition test | [ ] |
| FIX 2 | Privilege escalation via ID mismatch (`.eq('id', ...)` vs `.eq('user_id', ...)`) | `tests/unit/lib/auth.test.ts` ‚Äî "uses user_id not id" | [ ] |
| FIX 3 | Missing Zod validation on admin mutations | `tests/integration/api/admin-members.test.ts` | [ ] |
| FIX 4 | CTF flag leakage via client query | `tests/integration/db/rls.test.ts` + `tests/e2e/ctf.spec.ts` | [ ] |
| FIX 5 | Orphaned auth users (app-layer rollback) | `tests/integration/db/triggers.test.ts` ‚Äî auth trigger test | [ ] |
| FIX 6 | `club_post` social engineering | `tests/unit/lib/validations.test.ts` ‚Äî club_post not in schema | [ ] |
| FIX 7 | Server client using anon key | Grep: `SUPABASE_SERVICE_ROLE_KEY` in `lib/supabase-server.ts` | [ ] |
| FIX 8 | TypeScript `any` contagion | Pre-flight check: `grep -r ": any"` | [ ] |
| FIX 9 | Cookie destruction on ban | `tests/e2e/auth.spec.ts` ‚Äî banned user test | [ ] |
| FIX 10 | No rate limiting | `tests/integration/api/ctf-submit.test.ts` ‚Äî rate limit test | [ ] |

---

## REGRESSION TEST SUITE

Run this full suite before every deployment:

```bash
# 1. TypeScript check
npx tsc --noEmit

# 2. Unit tests
npx vitest run tests/unit --reporter=verbose

# 3. Integration tests (requires test Supabase project)
npx vitest run tests/integration --reporter=verbose

# 4. E2E tests (requires running Next.js server)
npx playwright test

# 5. Security scan
npx vitest run tests/integration/db/rls.test.ts --reporter=verbose

# 6. CTF security scan
npx vitest run tests/integration/api/ctf-submit.test.ts --reporter=verbose

# 7. Coverage report
npx vitest run --coverage

# Expected: All pass, coverage ‚â• 80%
```

---

## CONTINUOUS QUALITY CHECKS

Add these as git pre-commit hooks (`/.husky/pre-commit`):

```bash
#!/bin/sh
set -e

echo "üîç Running ICEHC Portal pre-commit checks..."

# 1. TypeScript
echo "‚Üí TypeScript check..."
npx tsc --noEmit

# 2. No console.log
echo "‚Üí Checking for console.log..."
if grep -r "console\.log" --include="*.ts" --include="*.tsx" app/ lib/ components/ | grep -v ".test."; then
  echo "‚ùå console.log found. Remove before committing."
  exit 1
fi

# 3. No `any` types
echo "‚Üí Checking for 'any' types..."
if grep -r ": any\b\|as any\b" --include="*.ts" --include="*.tsx" app/ lib/ components/; then
  echo "‚ùå 'any' types found. Use 'unknown' and narrow."
  exit 1
fi

# 4. No select('*')
echo "‚Üí Checking for select('*')..."
if grep -r "\.select\('\*'\)" --include="*.ts" --include="*.tsx" app/ lib/; then
  echo "‚ùå .select('*') found. Use explicit column lists."
  exit 1
fi

# 5. flag_hash not in portal pages
echo "‚Üí Checking flag_hash exposure..."
if grep -r "flag_hash" --include="*.tsx" app/portal/; then
  echo "‚ùå CRITICAL: flag_hash referenced in portal pages."
  exit 1
fi

# 6. Service role key not in NEXT_PUBLIC prefix
echo "‚Üí Checking env variable safety..."
if grep -r "NEXT_PUBLIC_SUPABASE_SERVICE" --include="*.ts" --include="*.tsx" .; then
  echo "‚ùå CRITICAL: Service role key has NEXT_PUBLIC prefix."
  exit 1
fi

# 7. Unit tests
echo "‚Üí Running unit tests..."
npx vitest run tests/unit --reporter=dot

echo "‚úÖ All pre-commit checks passed."
```

---

## QUICK REFERENCE ‚Äî QA DO / DON'T

| ‚úÖ DO | ‚ùå DON'T |
|---|---|
| Test all three roles for every gated route | Test only the happy path (admin success) |
| Use `ICEHC{test_flag_qa_only}` in fixtures | Use real challenge flags in tests |
| Verify `flag_hash` is not in any API response | Assume the RLS policy is enough |
| Run race condition test on CTF submission | Trust that "it probably won't happen" |
| Check `user_id` (not `id`) in every auth lookup | Skip the ID field check |
| Test 429 response from rate limiters | Assume rate limiters are working |
| Document bugs with the template before fixing | Fix and forget |
| Run full regression suite before every deploy | Run only the changed test file |
| Verify ban clears ALL `sb-*` cookies | Test only the redirect destination |
| Check `club_post` is not accepted from client | Trust Zod will catch it later |
| Test pending/rejected/banned states in middleware | Test only the approved state |
| Verify dark styling is ONLY on code/CTF blocks | Let dark backgrounds creep into cards |
| Assert IIMS Navy and Crimson are correct hex | Eyeball the color and call it good |
| Assert `import 'server-only'` in all server libs | Assume the bundler will catch leaks |

---

*QA & BUG-FIXING AGENT PROMPT v1.0 ‚Äî ICEHC Portal.*
*Feed after `CONTEXT.md` + `AGENT_PROMPT.md` + `BACKEND_LOGIC_PROMPT.md`.*
*Every QA session must start with the Pre-Flight Checklist. Every fix must have a passing test.*
*Club: IIMS Cybersecurity & Ethical Hacking Club (ICEHC), IIMS College, Kathmandu, Nepal, 2026.*